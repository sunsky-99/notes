

/*
索引（index）是帮助MySQL高效获取数据的数据结构
无索引查询 全表扫描 速率极低
索引主要分为四种：普通索引、主键、唯一索引、复合索引
建立索引的优点：
1、索引能够提高数据检索的效率，降低数据库的IO成本。
2、通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性，创建唯一索引
3、在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间
4、加速两个表之间的连接，一般是在外键上创建索引
建立索引的缺点：
1、需要占用物理空间,建立的索引越多需要的空间越大
2、创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加
一般需要建立索引的字段
1、经常用在where语句之后的字段
2、主键或者外键
3、字段具有唯一性的时候建立唯一性索引
4、在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的

MySQL目前主要有以下索引类型： 
普通索引key 
唯一索引unique key
主键索引primary key
组合索引 index（name，age，gender）
全文索引 FULLTEXT

MySQL的索引结构主要包括有： 
BTree索引(B+树索引)、Hash索引、full-text索引(全文索引)、R-Tree索引(空间索引)
如果没有特别指明，都是指B+树别构的索引。
InnoDB存储引擎中的B+树索引是由二叉查找树，平衡二叉树和B树这三种数据结构演化过来的。
 
BTree索引(B+树索引) 	最常见索引类型，大部分引擎支持
Hash索引				底层数据结构哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询
full-text索引(全文索引)	是一种通过建立倒排索引，快速匹配文档的方式。类似于Lucene、Solr、ES
R-Tree索引(空间索引)	是MyISAM引擎的一个特殊索引类型，主要用于地理空间类型

BTree索引(B+树索引) 	支持 InnoDB、MyISAM、Memory
Hash索引				支持 Memory
full-text索引(全文索引)	支持 InnoDB、MyISAM
R-Tree索引(空间索引)	支持 MyISAM
*/

二叉查找树（Binary Search Tree，简称BST）是一棵二叉树，它的左子节点的值比父节点的值要小，右节点的值要比父节点的值大。它的高度决定了它的查找效率。
在理想的情况下，二叉查找树增删查改的时间复杂度为O(logN)（其中N为节点数），最坏的情况下为O(N)。当它的高度为logN+1时，我们就说二叉查找树是平衡的
BST存在的问题
BST存在的主要问题是，数在插入的时候会导致树倾斜，不同的插入顺序会导致树的高度不一样，而树的高度直接的影响了树的查找效率。理想的高度是logN，最坏的情况是所有的节点都在一条斜线上，这样的树的高度为N。
二叉树缺点 顺序插入时，会形成一个链表，查询性能大大降低。大数据量情况下，层级较深，检索速度慢
红黑树的特性
（1）每个节点或者是黑色，或者是红色。
（2）根节点是黑色。
（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]
（4）如果一个节点是红色的，则它的子节点必须是黑色的。
（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。[这里指到叶子节点的路径]
包含n个内部节点的红黑树的高度是 O(log(n)).

https://tech.meituan.com/2016/12/02/redblack-tree.html

RBTree
基于BST存在的问题，一种新的树——平衡二叉查找树(Balanced BST)产生了。平衡树在插入和删除的时候，会通过旋转操作将高度保持在logN。其中两款具有代表性的平衡树分别为AVL树和红黑树。AVL树由于实现比较复杂，而且插入和删除性能差，在实际环境下的应用不如红黑树。
红黑树（Red-Black Tree，以下简称RBTree）的实际应用非常广泛，比如Linux内核中的完全公平调度器、高精度计时器、ext3文件系统等等，各种语言的函数库如Java的TreeMap和TreeSet，C++ STL的map、multimap、multiset等。
RBTree也是函数式语言中最常用的持久数据结构之一，在计算几何中也有重要作用。值得一提的是，Java 8中HashMap的实现也因为用RBTree取代链表，性能有所提升。
RBTree的定义如下:
任何一个节点都有颜色，黑色或者红色。
根节点是黑色的。
父子节点之间不能出现两个连续的红节点。
任何一个节点向下遍历到其子孙的叶子节点，所经过的黑节点个数必须相等。
空节点被认为是黑色的。

B-Tree
B-tree，即B树，它是一种多路搜索树（并不是二叉的）：
B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；
B-树的特性：
1.关键字集合分布在整颗树中；
2.任何一个关键字出现且只出现在一个结点中；
3.搜索有可能在非叶子结点结束；
4.其搜索性能等价于在关键字全集内做一次二分查找；
5.自动层次控制；
　　由于限制了除根结点以外的非叶子结点，至少含有M/2个儿子，确保了结点的至少利用率，其最底搜索性能为：O（logN）
　　所以B-树的性能总是等价于二分查找（与M值无关），也就没有B树平衡的问题；
由于M/2的限制，在插入结点时，如果结点已满，需要将结点分裂为两个各占M/2的结点；删除结点时，需将两个不足M/2的兄弟结点合并；

B+Tree
在B-Tree的基础上优化了：
1、节点上只存储键值，不存储数据，这样一来，在有限的节点空间（页空间）内就可以存放更多的键值、指针；
2、所有数据都放在叶子节点中，所有叶子节点之间有链指针（双向循环列表），便于范围查找，也便于排序。

btree和b+tree的区别：
1、btree的关键字和记录是放在一起的，叶子节点可以看作外部节点，不包含任何信息；b+tree的非叶子节点中只有关键字和指向下一个节点的索引，记录只放在叶子节点中。
2、在btree中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在；而b+tree中每个记录的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。


在InnoDB存储引擎中一般使用的是B+树索引。其实mysql中还有另一种常见的索引即哈希索引；在Memory存储引擎中就支持哈希索引，同时在InnoDB存储引擎中也支持自适应哈希索引，可以与B+树索引共同使用

哈希索引 
数据库中哈希索引是基于哈希表实现的，对于哈希索引列的数据通过 Hash 算法计算，得到对应索引列的哈希码形成哈希表，由哈希码及哈希码指向的真实数据行的指针组成了哈希索引。

哈希索引的特点 
哈希索引只适用于等值查询，不支持范围查询。等值查询包括 =、IN()、<=> （安全等于， select null <=> null 和 select null=null 是不一样的结果) 

哈希索引的性能
哈希索引的性能跟哈希冲突数量成反比，哈希冲突越多其维护代价越大性能越低 。Hash 碰撞通用的处理方法是使用链表，将 Hash 冲突碰撞的元素形成一个链表，发生冲突时在链表上进行二次遍历找到数据。

Hash 碰撞跟选择的 Hash 算法有关系，为了减少 Hash 碰撞的概率，优先选择避免 Hash 冲突的 Hash 算法，例如，使用 Percona Server 的函数 FNV64() ，其哈希值为 64 位，出现 Hash 冲突的概率要比 CRC32 小很多。

InnoDB中的自适应哈希索引
InnoDB 自适应哈希索引是为了提升查询效率，InnoDB 存储引擎会监控表上各个索引页的查询，当 InnoDB 注意到某些索引值访问非常频繁时，会在内存中基于 B+Tree 索引再创建一个哈希索引，使得内存中的 B+Tree 索引具备哈希索引的功能，即能够快速定值访问频繁访问的索引页。

为什么要为 B+Tree 索引页二次创建自适应哈希索引呢？

因为 B+Tree 索引的查询效率取决于 B+Tree 的高度，在数据库系统中通常 B+Tree 的高度为 3～4 层，所以访问数据需要做 3～4 次的查询。而 Hash 索引访问通常一次查找就能定位数据（无 Hash 碰撞的情况），其等值查询场景 Hash 索引的查询效率要优于 B+Tree。

InnoDB自适应哈希索引开关
InnoDB 自适应哈希索引的功能，用户只能选择开启或关闭功能，无法进行人工干涉。

功能开启后可以通过 Show Engine Innodb Status 看到当前自适应哈希索引的使用情况：

Hash table size 276707， node heap has 0 buffer(s)

0.00 Hash searches/s， 0.00 non-Hash searches/s

可以看到 Hash table 的大小，使用情况及每秒使用 AHI 和非 AHI 搜索的情况。
 
原文链接：https://blog.csdn.net/qq_29569183/article/details/120896342


B+树与B树的不同在于：
（1）所有关键字存储在叶子节点，非叶子节点不存储真正的data
（2）为所有叶子节点增加了一个链指针

 

那么问题来了，为什么用B/B+树这种结构来实现索引呢？？
答：红黑树等结构也可以用来实现索引，但是文件系统及数据库系统普遍使用B/B+树结构来实现索引。mysql是基于磁盘的数据库，索引是以索引文件的形式存在于磁盘中的，索引的查找过程就会涉及到磁盘IO(为什么涉及到磁盘IO请看文章后面的附加理解部分)消耗，磁盘IO的消耗相比较于内存IO的消耗要高好几个数量级，所以索引的组织结构要设计得在查找关键字时要尽量减少磁盘IO的次数。为什么要使用B/B+树，跟磁盘的存储原理有关。

局部性原理与磁盘预读
为了提升效率，要尽量减少磁盘IO的次数。实际过程中，磁盘并不是每次严格按需读取，而是每次都会预读。磁盘读取完需要的数据后，会按顺序再多读一部分数据到内存中，这样做的理论依据是计算机科学中注明的局部性原理：

当一个数据被用到时，其附近的数据也通常会马上被使用
程序运行期间所需要的数据通常比较集中
（1）由于磁盘顺序读取的效率很高(不需要寻道时间，只需很少的旋转时间)，
因此对于具有局部性的程序来说，预读可以提高I/O效率.预读的长度一般为页(page)的整倍数。
（2）MySQL(默认使用InnoDB引擎),将记录按照页的方式进行管理,每页大小默认为16K(这个值可以修改)。linux 默认页大小为4K。

B-Tree借助计算机磁盘预读的机制，并使用如下技巧：
每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个结点只需一次I/O。
假设 B-Tree 的高度为 h,B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3，也即索引的B+树层次一般不超过三层，所以查找效率很高）。
而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。

为什么mysql的索引使用B+树而不是B树呢？？
（1）B+树更适合外部存储(一般指磁盘存储),由于内节点(非叶子节点)不存储data，所以一个节点可以存储更多的内节点，每个节点能索引的范围更大更精确。也就是说使用B+树单次磁盘IO的信息量相比较B树更大，IO效率更高。
（2）mysql是关系型数据库，经常会按照区间来访问某个索引列，B+树的叶子节点间按顺序建立了链指针，加强了区间访问性，所以B+树对索引列上的区间范围查询很友好。而B树每个节点的key和data在一起，无法进行区间查找。

------------------

B-Tree    简单理解： 二分查找；

B+    简单理解：内节点不存储数据了，改成存储内节点，一次IO操作，可以查到更多的数据，最终IO次数比B-Tree少，效率更高了



InnoDB存储引擎中，根据索引的存储形式可以分两种
聚集索引(clustered index)、辅助索引(有时也称非聚簇索引或二级索引，secondary index，non-clustered index)
聚集索引是将索引列字段和行记录数据维护在了一起,它的叶子节点存储的是 索引列字段 + 完整的行记录数据,通过聚集索引能直接获取到整行数据
Innodb 的主键索引就是基于聚集索引实现的

因为表中存储的数据是通过聚集索引组织在一起的,所以聚集索引必须要有,否则我们无法获取到表中的行数据,并且聚集索引还只能存在一个
既然聚集索引必须要有,可是有时候我们创建表的时候并没有设置主键,表照样创建成功,那么还有没有聚集索引呢?如果没有聚集索引 Innodb 的数据靠什么来组织维护呢?
如果存在主键,那么主键索引就是聚集索引
如果不存在主键,将会使用第一个唯一(UNIQUE)、非空的索引作为聚集索引
如果表中既没有主键索引,又没有合适的唯一索引,那么 Innodb 会自动维护一个 row_id(默认大小为 6B)来作为隐藏的聚集索引
为什么聚集索引只能存在一个呢?
是为了节省磁盘空间和保证数据的一致性,这个我们在 Innodb 的非聚集索引中那一块再讲

2、非聚集索引
非聚集索引是相比较于聚集索引来说,它是把索引和行数据分开维护,叶子节点并没有包含完整的数据记录
(叶子节点的数据区存储的是聚集索引的 id 或 数据的磁盘地址)Mysql 非聚集索引底层的数据结构也是 b+ 树,例如 Myisam 的索引、Innodb 的辅助索引

叶子节点存放的是 索引列的值 + 对应行记录的主键 id 值
例如要查找 select * from user where age = 41 ,它的查找过程是什么样的呢?
首先由于 age 是索引,并且 where 中使用了索引作为条件,我们需要从索引树的根节点(36) 开始,将该节点对应的 page 页从磁盘加载进内存,在内存中进行比较, 由于 41 > 36 ,根据根节点指针,搜寻到 B+ 树第二层的节点(36),再接着将第二层的节点(36) 所在的 page 从磁盘加载进内存,在内存中进行比较,由于 41 > 36,继续走右边节点来到第三层叶子节点,将叶子节点(36,41)从磁盘加载进内存,在内存中比较有没有索引值等于 41 的数据,结果找到了 41,并且同时 41 下面还挂着该记录行的主键 id(13),然后接着根据主键 id(13) 回到主键索引(聚集索引)上找到 id 为 13 的行记录,取出对应的数据即可
当通过非聚集索引来查询数据时,存储引擎会根据索引字段定位到最底层的叶子节点,并通过叶子节点获得指向主键索引的主键 id,然后通过主键 id 去主键索引(聚集索引)上找到一个完整的行记录.这个过程被称为 回表

为什么非聚集索引的叶子节点存储的是聚集索引的 id 值(或数据的磁盘地址值),直接跟聚集索引一样,把完整的数据放在非聚集索引的叶子节点不好吗,这样还不用回表查询,直接就能拿到结果
之所以这么做是为了数据的一致性和节省磁盘空间
1、假设一张表里面有 10 个索引,就要在这 10 个索引上分别维护一份相同的表数据,而数据都是存储在磁盘上的,那么磁盘就会存储 10 份相同的数据,对磁盘的压力大,尤其是现在的磁盘多是用 SSD 来存储的,价格较高
2、插入、更新、删除数据的时候,Mysql 就要同时维护 10 份一样的数据以保证数据的一致性,如果在维护数据的时候有一个出现了错误,那不就导致了数据不一致了吗,这也同时解释了为什么 Innodb 存储引擎的聚集索引只能有一个,因为只需要维护一份完整的数据就足够了


-- 查看索引
SHOW INDEX FROM SYS_USER ;

-- 创建普通索引
CREATE INDEX INDEX_SYS_USER_NAME ON SYS_USER(NAME);
CREATE INDEX INDEX_SYS_USER_ORGANIZATION_ID ON SYS_USER(ORGANIZATION_ID);

-- 创建唯一索引
CREATE UNIQUE INDEX INDEX_SYS_USER_MOBILE ON SYS_USER(MOBILE);
CREATE UNIQUE INDEX INDEX_SYS_USER_EMAIL ON SYS_USER(EMAIL);

-- 创建联合索引
CREATE INDEX INDEX_SYS_USER_TEST123 ON SYS_USER(TEST1,TEST2,TEST3);

-- 删除索引
DROP INDEX INDEX_SYS_USER_ORGANIZATION_ID ON SYS_USER;



