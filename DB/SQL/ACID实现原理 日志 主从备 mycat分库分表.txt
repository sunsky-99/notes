ACID实现原理

原子性、一致性、持久性 	实现原理redo log、undo log
隔离性					实现原理 锁、mvcc


redo log
重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。
该日志文件由两部分组成:
重做日志缓冲(redo log bufer)以及重做日志文件(redo log file),前者是在内存中，后者在磁盘中。
当事务提交之后会把所有修改信息都存到该日志文件中,用于在刷新脏页到磁盘,发生错误时，进行数据恢复使用。


undo log
回滚日志，用于记录数据被修改前的信息，作用包含两个:提供回滚和MVCC(多版本并发控制)。
undolog和redolog记录物理日志不一样，它是逻日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。
Undo log销毁:undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC
Undo log存储: undo log采用段的方式进行管理和记录，存放在前面介绍的 rolback segment 回滚段中，内部包含1024个undo log segment。

MVCC-基本概念
当前读
读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如:select ... lock in share mode(共享锁)，select... for update、update、insert、delete(排他锁)都是一种当前读

快照读
简单的select(不加锁)就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。
Read Committed:每次select，都生成一个快照读。
Repeatable Read:开启事务后第一个select语句才是快照读的地方。
Serializable:快照读会退化为当前读。


MVCC
全称 Multi-version Concurrency Control，多版本并发控制。
指维护个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readview。

隐藏字段					含义
DB_TRX_ID			最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。
DB_ROLL_PTR			回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本
DB_ROW_ID 			隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。

undo log
回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志.
当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除.
而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。

undo log版本链
不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。

readview
ReadView(读视图)是 快照读 SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务(未提交的)id。
ReadView中包含了四个核心字段:
m_ids			当前活跃的事务ID集合
min_trx_id		最小活跃事务ID
max_trx_id		预分配事务ID，当前最大事务ID+1(因为事务ID是自增的)
creator_trx_id	ReadView创建者的事务ID

版本链数据访问规则	trx_id: 代表是当前事务ID。
1.trx_id = creator_trx_id				?可以访问该版本								成立，说明数据是当前这个事务更改的
2.trx_id < min_trx_id					?可以访问该版本								成立，说明数据已经提交了。
3.trx_id > max_trx_id					?不可以访问该版本								成立，说明该事务是在ReadView生成后才开启
4.min_trx_id <= trx_id <= max_trx_id	?如果trx_id不在m_ids中是可以访问该版本的		成立，说明数据已经提交。

不同的隔离级别，生成Readview的时机不同
READ COMMITTED : 在事务中每一次执行快照读时生成ReadView。
REPEATABLE READ: 仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。


逻辑存储结构
表空间、段、区、页、行

架构
	内存结构
	磁盘结构

事务原理
	原子性 - undo log
	持久性 - redo lcg
	一致性 - undo log + redo log
	隔离性 - 锁+ MVCC

MVCC
	三个隐式字段、undo log版本链、readview。
	
	
Mysql数据库安装完成后，自带了一下四个数据库，具体作用如下:
	mysql				存储MySQL服务器正常运行所需要的各种信息 (时区、主从、用户、权限等)
	information_schema	提供了访问数据库元数据的各种表和视图，包含数据库、表、字段类型及访问权限等
	performance_schema	为MySQL服务器运行时状态提供了一个底层监控功能，主要用于收集数据库服务器性能参数
	sys					包含了一系列方便DBA和开发人员利用 performance_schema 性能数据库进行性能调优和诊断的视图
	
	
1.mysql
	Mysql 客户端工具，-e 执行SQL并退出
2.mysqladmin
	Mysql管理工具
3.mysqlbinlog
	二进制日志查看工具
4.mysglshow
	查看数据库、表、字段的统计信息
5.mysgldump
	数据备份工具
6.mysqlimport/source
	数据导入工具
	



------------------------------------------------------------------------------------------------------------
日志
	错误日志
	二进制日志
	查询日志
	慢查询日志
	
错误日志
	错误日志是 MySQL中最重要的日志之一，它记录了当 mysgld 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。
	当数据库出现任何故障导致无法正常使用时，建议首先查看此日志。
	该日志是默认开启的，默认存放目录 /var/log/，默认的日志文件名为 mysgld.log 。
	查看日志位置:
	show variables like '%log_error%';
二进制日志
	二进制日志 (BINLOG)记录了所有的 DDL(数据定义语言)语 DML(数据操纵语言)语句，但不包括数据查询SELECT、SHOW)语句。
	作用:@.灾难时的数据恢复，@.MySQL的主从复制。在MySQL8版本中，默认二进制日志是开启着的，涉及到的参数如下:
	show variables like '%log_bin%';
	
	MySQL服务器中提供了多种格式来记录二进制日志，具体格式及特点如下:
	STATEMENT	基于SQL语句的日志记录，记录的是SQL语句，对数据进行修改的SQL都会记录在日志文件中。
	ROW			基于行的日志记录，记录的是每一行的数据变更。(默认)
	MIXED		混合了STATEMENT和ROW两种格式，默认采用STATEMENT，在某些特殊情况下会自动切换为ROW进行记录。
	show variables like '%binlog_format%';
	
	日志删除
	对于比较繁忙的业务系统，每天生成的binlog数据巨大，如果长时间不清除，将会占用大量磁盘空间。可以通过以下几种方式清理日志:
	reset master										删除全部 binlog 日志，删除之后，日志编号，将从 binlog.000001重新开始
	purge master logs to 'binlog.******'				删除******编号之前的所有日志
	purge master logs before 'yyyy-mm-dd hh24:mi:ss'	删除日志为'yyyy-mm-dd hh24:mi:ss'之前产生的所有日志
	
	也可以在mysql的配置文件中配置二进制日志的过期时间、设置了之后，二进制日志过期会自动删除。
	show variables like '%binlog_expire_logs_seconds%';
查询日志	
	查询日志中记录了客户端的所有操作语句，而二进制日志不包含查询数据的SQL语句。默认情况下，查询日志是未开启的。
	如果需要开启查询日志，可以设置以下配置:
	show variables like '%general%';
	修改MySQL的配置文件 /etc/my.cnf 文件，添加如下内容
	#该选项用来开启查询日志 ， 可选值 : 0或者 1; 0代表关闭，1代表开启
	general_log=1 
	#设置日志的文件名，如果没有指定，默认的文件名为 host_name.log
	general_log_file=mysql_query.log
慢查询日志
	慢查询日志记录了所有执行时间超过参数 ong_query_time 设置值并且扫描记录数不小于 min_examined_row_limit的所有的SQL语句的日志，默认未开启。
	long_query_time 默认为 10 秒，最小为0，精度可以到微秒。
	#慢查询日志
	slow_queny_log=1
	#执行时间参数
	long_query_time=2
	
	默认情况下，不会记录管理语句，也不会记录不使用索引进行查找的查询。可以使用log_slow_admin_statements和更改此行为log_queries_not_using_indexes，如下所述。
	#记录执行较慢的管理语句
	log_slow_admin_statements=1
	#记录执行较慢的未使用索引的语句
	log_queries_not_using_indexes=1
	
	
	
	
-----------------------------------------------------------------------------------------------------------------------------------------------
主从复制是指将主数据库的DDL和 DML 操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行(也叫重做)，从而使得从库和主库的数据保持同步。
MySQL支持一台主库同时向多台从库进行复制，从库同时也可以作为其他从服务器的主库，实现链状复制。
MySQL复制的有点主要包含以下三个方面:
1.主库出现问题，可以快速切换到从库提供服务
2.实现读写分离，降低主库的访问压力。
3.可以在从库中执行备份，以避免备份期间影响主库服务


1.Master 主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog中
2.从库读取主库的二进制日志文件 Binlog，写入到从库的中继日志Relay Log。
3.slave重做中继日志中的事件，将改变反映它自己的数据


开放指定的3306端口号:
firewall-cmd --zone=public --add-port=3306/tcp -permanent
firewall-cmd -reload
关闭服务器的防火墙 :
systemctl stop firewalld
systemctl disable firewalld

主库配置

1.修改配置文件/etc/my.cnf
#mysql 服务ID，保证整个集群环境中唯一，取值范围: 1 - 2的32次方-1，默认为1
server-id=1
#是否只读,1 代表只读,0 代表读写
read-only=0
#忽略的数据,指不需要同步的数据库
#binlog-ignore-db=mysql
#指定同步的数据库
#binlog-do-db=db01
2.重启MySQL服务
systemctl restart mysqld 
3.登录mysql，创建远程连接的账号，并授予主从复制权限
#创建itcast用户，并设置密码，该用户可在任意主机连接该MySQL服务
CREATE USER 'itcast'@'%' IDENTIFIED WITH mysql_native_password BY 'Root@123456';
#为'itcast'@'%' 用户分配主从复制权限
GRANT REPLICATION SLAVE ON *.* TO 'itcast'@'%';
4.通过指令，查看二进制日志坐标
show master status ;
file:从哪个日志文件开始推送日志文件
position:从哪个位置开始推送日志
binlog_ignore_db:指定不需要同步的数据库

从库配置
1.修改配置文件/etc/my.cnf
#mysql服务ID，保证整个集群环境中唯一，取值范围: 1 - 2的32次方-1，和主库不一样即可 
server-id=2
#是否只读,1 代表只读,0 代表读写
read-only=1
2.重启MySQL服务
systemctl restart mysqld 
3.登录mysql，设置主库配置
CHANGE REPLICATION SOURCE TO SOURCE_HOST='xx.xx.xx',SOURCE_USER='xxx',  SOURCE_PASSWORD='xxx', SOURCE_LOG_FILE='xxx', SOURCE_LOG_POS='xxx';
4.开启同步
start replica ;
5.查看主从同步状态
show replica status ;
上述是8.0.23中的语法。如果mysql是8.0.23之前的版本，执行如下SQL:
CHANGE MASTER TO MASTER_HOST='xx.xx.xx',MASTER_USER='xxx',MASTER_PASSWORD='xxx',MASTER_LOG_FILE='xxx',MASTER_LOG_POS='xxx';
开启同步
start slave；
show slave status ;

主库IP地址				SOURCE_HOST			MASTER_HOST
连接主库的用户名			SOURCE_USER			MASTER_USER
连接主库的密码				SOURCE_PASSWORD		MASTER_PASSWORD
binlog日志文件名			SOURCE_LOG_FILE		MASTER_LOG_FILE
binlog日志文件位置		SOURCE_LOG_POS		MASTER_LOG_POS

主从复制概述
将主库的数据变更同步到从库，从而保证主库和从库数据一致数据备份、失败迁移，读写分离，降低单库读写压力

主从复制原理 
1.主库会把数据变更记录在二进制日志文件 Binlog 中
2.从库连接主库，读取binlog日志，并写入自身中继日志 relaylog。
3.slave重做中继日志，将改变反映它自己的数据。






分库分表
分库分表的中心思想都是将数据分散存储，使得单一数据库/表的数据量变小来缓解单一数据库的性能问题，从而达到提升数据库性能的目的。

随着互联网及移动互联网的发展，应用系统的数据量也是成指数式增长，若采用单数据库进行数据存储，存在以下性能瓶颈:
1，IO瓶颈:热点数据太多，数据库缓存不足，产生大量磁盘IO，效率较低。请求数据太多，带宽不够，网络10瓶颈。
2. CPU瓶颈:排序、分组、连接查询、聚合统计等SQL会耗费大量的CPU资源，请求数太多，CPU出现瓶颈。

拆分策略
垂直拆分	垂直分库	垂直分表
水平拆分	水平分库	水平分表

垂直分库:以表为依据，根据业务将不同表拆分到不同库中
1. 每个库的表结构都不一样。
2. 每个库的数据也不一样。
3. 所有库的并集是全量数据。

垂直分表:以字段为依据，根据字段属性将不同字段拆分到不同表中
1.每个表的结构都不一样
2.每个表的数据也不一样，一般通过一列(主键/外键)关联。
3.所有表的并集是全量数据



水平分库:以字段为依据，按照一定策略，将一个库的数据拆分到多个库中。
1.每个库的表结构都一样 
2.每个库的数据都不一样。
2.所有库的并集是全量数据

水平分表:以字段为依据，按照一定策略，将一个表的数据拆分到多个表中。
1.每个表的表结构都一样
2.每个表的数据都不一样 
3.所有表的并集是全量数据


Mycat是开源的、活跃的、基于Java语言编写的MVSOL数据库中间件。可以像使用mysql一样来使用mycat，对于开发人员来说根本感觉不到mycat的存在。