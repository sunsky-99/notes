-- SQL性能分析
-- SQL执行频率 增删改查执行频率 SHOW GLOBAL/SESSION STATUS LIKE 'Com_______'
-- GLOBAL全局信息  SESSION当前会话的信息
SHOW SESSION STATUS LIKE 'Com_______';
SHOW GLOBAL STATUS LIKE 'Com%';

慢查询日志
-- 慢查询日志开关是否开启
show variables like 'slow_query_log';

慢查询日志默认关闭，修改 /etc/my.cnf
# 开启慢查询日志
slow_query_log = 1
# 设置慢查询的时间 查询超过该时间视为慢查询 (单位默认s)
long_query_time = 1

配置完成,慢SQL日志位置 /var/lib/mysql/localhost-slow.log

查看慢日志 cat /var/lib/mysql/localhost-slow.log

实时刷新查看慢日志文件 tail -f  /var/lib/mysql/localhost-slow.log



# PROFILE  SQL优化时 发现时间耗费在哪
# 查询数据库是否支持PROFILE操作
SELECT @@HAVE_PROFILING;

# 查看数据库PROFILING操作是否开启 默认0关闭 1开启
SELECT @@PROFILING;

# 开启或关闭PROFILING  SET SESSION/GLOBAL(当前session或全局) PROFILING = 0/1 ;
SET PROFILING = 1;

# 查看每一条SQL基本耗时情况
SHOW  PROFILES;

# 查看指定query_id的SQL语句各个阶段的耗时情况
SHOW  PROFILE FOR QUERY 13;

# 查看指定query_id的SQL语句CPU的使用情况
SHOW PROFILE CPU FOR QUERY 13;



# explain执行计划
1、explain的基本介绍
有时候我们可能需要知道 mysql 是如何解析执行我们的 SQL 语句的，比如有时候某些语句写在前面并不一定意味着它就会先执行，有没有使用到索引等待，此时我们可以通过 explain 语句来分析出 SQL 优化器是如何解析执行我们的 SQL 语句的。

使用 EXPLAIN 关键字可以模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的，explain 主要用于分析查询语句或表结构的性能瓶颈。
 
1.1、explain的作用
通过explain+sql语句可以知道如下内容：

表的读取顺序（对应id）。
数据读取操作的操作类型（对应select_type）。
哪些索引可以使用（对应possible_keys）。
哪些索引被实际使用（对应key）。
表直接的引用（对应ref）。
每张表有多少行被优化器查询（对应rows）。

2、explain的基本使用
使用 explain 关键字来分析 SQL 语句的性能，只需要在 SQL 语句的前面加上 explain 即可
EXPLAIN SELECT * FROM  SYS_USER WHERE USER_ID = 1;

3、explain的字段意思
使用 expain 分析 SQL 性能时，列出来的信息有10列，分别是id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra。

概要描述：

id：表的读取顺序 id相同 执行顺序从上到下；id不同，值越大越先执行
select_type：数据读取操作的操作类型。 SIMPLE(简单表，不用表连接或者子查询);PRIMARY(主查询，即最外层的查询);UNION(UNION中的第二个或者后面的查询语句);SUBQUERY(select/WHERE之后包含了子查询)等
table：该查询是基于哪张表的
partitions：匹配的分区

type：表示查询的连接类型   性能由好到差为 null、system、const、eq_ref、ref、range、index、all

possible_keys：哪些索引可以使用 
key：哪些索引被实际使用
key_len：索引字段的长度
ref：表直接的引用
rows：扫描出的行数（估算的行数）
filtered：按表条件过滤的行百分比
Extra：执行情况的描述和说明



复合索引使用
	最左前缀法则 如果索引了多列(联合索引)，要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳越某一列，索引将部分失效(后面的字段索引失效)
	范围查询 联合索引中，出现范围查询(>,<),范围查询右侧的列索引失效

不要在索引列上进行运算操作，索引将失效
字符串类型字段使用时，不加引号，索引将失效
模糊查询，尾部模糊匹配，索引不会失效；头部模糊匹配，索引将失效

or连接的条件
用or分割开的条件，如果or前的条件中的列有索引，后面的列中没有索引，那么涉及到的索引都不会被用到

数据分布影响
如果MySQL评估使用索引比全表更慢，则不使用索引	

SQL提示，是优化数据库的一个重要过程，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的
use index 建议mysql使用哪一个索引来完成此次查询（仅仅只是建议，mysql内部还是会在此进行评估）
select * from table_name use index(index_name) where id = 1 ;

ignore index 忽略指定索引
select * from table_name ignore index(index_name) where id = 1 ;

force index 强制使用索引
select * from table_name force index(index_name) where id = 1;

覆盖索引	不需要回表查询
理解方式一：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了他们索引的数据；当能够通过读取索引就可以得到想要的数据，那就不需要读取行了。一个索引包含了满足查询结果的数据就叫做覆盖索引。
理解方式二：非聚簇复合索引的一种形式，它包括在查询的select join 和where子句用到的所有列（即建索引的字段正好是覆盖查询条中所涉及的字段）。
简单说就是索引+主键包含select 到from之间查询的列 


前缀索引 
一.什么是前缀索引
所谓前缀索引说白了就是对字符串的前n个字符建立索引
二.为什么选择前缀索引
一般来说使用前缀索引，可能都是因为整个字段的数据量太大，没有必要针对整个字段建立索引，前缀索引仅仅是选择一个字段的前n个字符作为索引，这样一方面可以节约索引空间，另一方面则可以提高索引效率，当然很明显，这种方式也会降低索引的选择性。这里又涉及到一个概念，索引选择性
三.什么是索引选择性
它是指不重复的索引值和数据表的记录总数的比值，取值范围在 [0,1] 之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让 MySQL 在查找时过滤掉更多的行。
那是不是选择性越高的索引越好呢？也不全是，就拿唯一索引举例，数据具有唯一性，那么索引选择性肯定为1，搜索时能直接通过搜索条件定位到具体一行记录，这个时候虽然性能最好，但是也是最费空间的（相对于前缀），而前缀恰恰就是希望能够在索引的性能和空间之间找到一个平衡，我们希望能够选择足够长的前缀以保证较高的选择性，但是又希望索引不要太过于占用存储空间。
四.前缀索引的n应该怎么确定
那么我们该如何选择一个合适的索引选择性呢？索引前缀应该足够长，以便前缀索引的选择性接近于索引的整个列，即前缀的基数应该接近于完整列的基数

在业务场景中，如果存在多个查询条件，考虑针对查询字段建立索引时，建议建立联合索引


针对于数据量较大，且查询比较频繁的表建立索引。
针对于常作为查询条件 (where)、排序 (order by)、分组(group by) 操作的字段建立索引。
尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。
如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。
尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率
要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。
如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。


insert优化
批量插入 如果需要同时对一张表插入很多行数据时，应该尽量使用多个值表的insert语句，这种方式将大大的缩减客户端与数据库之间的连接、关闭等消耗。使得效率比分开执行的单个insert语句快。;
示例， 优化方式为：
Insert into tb_test values(1,'Tom'),(2,'Cat'),(3,'Jerry');
手动提交事务 由于mysql中事务是自动提交，每插入一次就会开启提交一次，如果插入多次数据会很大程度造成效率的浪费！可以选择手动事务提交的方式，开启事务，插入多条数据之后，关闭事务;
start transaction;
insert into tb_test values(1,'Tom'),(2,'Cat'),(3,'Jerry');
insert into tb_test values(4,'Tom'),(5,'Cat'),(6,'Jerry');
insert into tb_test values(7,'Tom'),(8,'Cat'),(9,'Jerry');
commit;
主键顺序插入;
主键乱序插入 : 8 1 9 21 88 2 4 15 89 5 7 3
主键顺序插入 : 1 2 3 4 5 7 8 9 15 21 88 89

如果一次性插入大批量数据，用load指令
客户端连接服务端时加上参数 --local-infile 
mysql  --local-infile  -u root -p
设置全局参数local_infile为1，开启从本地加载文件导入数据的开关
set global loca_infile = 1;
执行load指令将准备好的数据加载到表结构中
LOAD DATA INFILE "/home/mark/data.sql" INTO TABLE Orders fields TERMINATED BY ',' lines TERMINATED BY '\n';

主键优化
1). 数据组织方式
在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（index organized table 简称IOT）
行数据，都是存储在聚集索引的叶子节点上的。
 在InnoDB引擎中，数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认16K。 那也就意味着， 一个页中所存储的行也是有限的，如果插入的数据行row在该页存储不小，将会存储 到下一个页中，页与页之间会通过指针连接。

2). 主键乱序插入会页分裂
页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据过大，会行 溢出)，根据主键排列。
A. 主键顺序插入效果
①. 从磁盘中申请页， 主键顺序插入
②. 第一个页没有满，继续往第一页插入 
③. 当第一个也写满之后，再写入第二个页，页与页之间会通过指针连接
④. 当第二页写满了，再往第三页写入
B. 主键乱序插入效果
①. 加入1#,2#页都已经写满了，存放了如图所示的数据 
②. 此时再插入id为50的记录，我们来看看会发生什么现象 会再次开启一个页，写入新的页中吗？ 
不会。因为，索引结构的叶子节点是有顺序的。按照顺序，应该存储在47之后。 
但是47所在的1#页，已经写满了，存储不了50对应的数据了。 那么此时会开辟一个新的页 3#。 
但是并不会直接将50存入3#页，而是会将1#页后一半的数据，移动到3#页，然后在3#页，插入50。
移动数据，并插入id为50的数据之后，那么此时，这三个页之间的数据顺序是有问题的。 1#的下一个 页，应该是3#， 3#的下一个页是2#。 所以，此时，需要重新设置链表指针。 
上述的这种现象，称之为 "页分裂"，是比较耗费性能的操作。 

3). 页合并
目前表中已有数据的索引结构(叶子节点)如下： 
当我们对已有数据进行删除时，具体的效果如下:
当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间 变得允许被其他记录声明使用。 
当我们继续删除2#的数据记录
当页中删除的记录达到 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前 或后）看看是否可以将两个页合并以优化空间使用。
删除数据，并将页合并之后，再次插入新的数据21，则直接插入3#页 
这个里面所发生的合并页的这个现象，就称之为 "页合并"。 
注意： MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或者创建索引时指定。

 4). 主键设计原则
1：满足业务需求的情况下，尽量降低主键的长度。
2：插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。
3：尽量不要使用UUID做主键或者是其他自然主键，如身份证号。
4：业务操作时，避免对主键的修改。

order by 优化
Using filesort:通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。
Using index:通过有序索引顺序扫描直接返回有序数据，这种情况即为using index，不需要额外排序，操作效率高。

根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。
尽量使用覆盖索引。
多字段排序,一个升序一个降序，此时需要注意联合索引在创建时的规则(ASC/DESC)。
如果不可避免的出现filesot，大数据量排序时，可以适当增大排序缓冲区大小 srt buffer size(默认256k)。

group by 优化
根据分组字段建立合适的索引，多字段分组时，也遵循最左前缀法则。

LIMIT 优化
一个常见又非常头疼的问题就是 limit 2000000,10 ，此时需要MySQL排序前2000010 记录，仅仅返回2000000 -2000010的记录，其他记录丢弃，查询排序的代价非常大
优化思路:一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。
explain select * from tb sku t , (select id from tb sku order by id limit 2000000,10) a where t.id = a.id;

count 优化
 MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行count(*)的时候会直接返回这个数，效率很高； 加了where条件后效率变低
 innoDB引擎就麻烦了，它执行 ount(*)的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。
 优化思路 自己计数
count的几种用法
count)是一个聚合函数，对于返回的结果集，一行行地判断，如果 ount 函数的参数不是 ULL，累计值就加1，否则不加，最后返回累计值。
用法: count (*)、count (主键)、count (字段) 、count (1)
count(主键)
InnoDB引擎会遍历整张表，把每一行的 主键id 值都取出来，返回给服务层。服务层拿到主键后，直接按行进行累加(主键不可能为nul)。
count(字段)
没有not null 约束:lnnoDB 引警会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为nul，不为nul，计数累加有not null 约束: InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加。
count (1)
nnoDB引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字“1”进去，直接按行进行累加。
count(*)
InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加。
按照效率排序的话，count(字段 count(主键 id)< count(1)  count(*)，所以尽量使用 count(*)。

UPDATE 优化
InnoDB的行锁是针对索引加的锁，不是针对记录加的锁,并且该索引不能失效，否则会从行锁升级为表锁。 where条件字段最好加索引



